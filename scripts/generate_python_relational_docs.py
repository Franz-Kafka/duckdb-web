import os

import duckdb

import inspect

import warnings

from generate_python_relational_docs_details import (
    DOCS_DETAILS_MAP,
    DEFAULT_EXAMPLE,
    PLACEHOLDER_EXAMPLE,
    PLACEHOLDER_RESULT,
    PythonRelAPIDetails,
)
from generate_python_relational_docs_methods import (
    CREATION_MEMBER_LIST,
    PY_RELATION_MEMBERS,
    DEFINITION_MEMBER_LIST,
    TRANSFORMATION_MEMBER_LIST,
    FUNCTION_MEMBER_LIST,
    OUTPUT_MEMBER_LIST,
)

DUCKDB_DOC_VERSION = os.getenv("DUCKDB_DOC_VERSION", "preview")

redirect_from_text = """\
redirect_from:
- /docs/api/python/relational_api
- /docs/api/python/relational_api/
- /docs/clients/python/relational_api
"""

FORMATTER_TEXT = f"""---
layout: docu
{redirect_from_text if DUCKDB_DOC_VERSION == 'stable' else ''}
title: Relational API
---

<!-- Generated by scripts/generate_python_relational_docs.py -->

<!-- markdownlint-disable MD001 -->

"""

INTRODUCTION_TEXT = """
The Relational API is an alternative API that can be used to incrementally construct queries. 
The API is centered around `DuckDBPyRelation` nodes. The relations can be seen as symbolic representations of SQL queries. 

## Lazy Evaluation

The relations do not hold any data – and nothing is executed – until [a method that triggers execution](#output) is called.

For example, we create a relation, which loads 1 billion rows:

```python
import duckdb

duckdb_conn = duckdb.connect()

rel = duckdb_conn.sql("from range(1_000_000_000)")
```
At the moment of execution, `rel` does not hold any data and no data is retrieved from the database.

By calling `rel.show()` or simply printing `rel` on the terminal, the first 10K rows are fetched.
If there are more than 10K rows, the output window will show >9999 rows (as the amount of rows in the relation is unknown).

By calling an [output](#output) method, the data is retrieved and stored in the specified format:

```python
rel.to_table("example_rel")

# 100% ▕████████████████████████████████████████████████████████████▏ 
```
"""

SECTION_MAP = {
    "Relation Creation": {
        "id": 1,
        "description": "This section contains the details on how a relation is created. \
        The methods are [lazy evaluated](#lazy-evaluation).",
        "method_list": [
            {"class": duckdb.DuckDBPyConnection, "members": CREATION_MEMBER_LIST}
        ],
    },
    "Relation Definition Details": {
        "id": 2,
        "description": "This section contains the details on how to inspect a relation.",
        "method_list": [
            {"class": duckdb.DuckDBPyRelation, "members": DEFINITION_MEMBER_LIST}
        ],
    },
    "Transformation": {
        "id": 3,
        "description": "This section contains the methods which can be used to chain queries.\
        The methods are [lazy evaluated](#lazy-evaluation).",
        "method_list": [
            {"class": duckdb.DuckDBPyRelation, "members": TRANSFORMATION_MEMBER_LIST}
        ],
    },
    "Functions": {
        "id": 4,
        "description": "This section contains the functions which can be applied to a relation, \
        in order to get a (scalar) result. The functions are [lazy evaluated](#lazy-evaluation).",
        "method_list": [
            {"class": duckdb.DuckDBPyRelation, "members": FUNCTION_MEMBER_LIST}
        ],
    },
    "Output": {
        "id": 5,
        "description": "This section contains the functions which will trigger an SQL execution and retrieve the data.",
        "method_list": [
            {"class": duckdb.DuckDBPyRelation, "members": OUTPUT_MEMBER_LIST}
        ],
    },
}


def trim_code_block(s):
    lines = s.splitlines()
    if not lines:
        return ""
    if lines[0].strip() == "":
        lines = lines[1:]
    if lines[-1].strip() == "":
        lines = lines[:-1]
    return "\n".join(lines)


def get_duckdb_conn():
    duckdb_conn = duckdb.connect()
    duckdb_conn.sql(
        """
        CREATE TABLE relational_api_members (
            class_name text,
            member_name text,
            section text,
            section_id integer,
            member_signature text,
            member_description text,
            member_parameters text,
            member_toc_line text,
            member_example text,
            member_result text,
            aliases text,
            primary key (class_name, member_name)
        )
    """
    )

    return duckdb_conn


def populate_member_details(relational_api_table, class_name, member_list, section):
    """

    :param relational_api_table: the table to store docs info
    :param class_name: the class to be inspected
    :param member_list: the list of methods to be inspected
    :param section: the section from the md file
    :return:
        For each method the doc is parsed into signature and description
        and the examples are rendered under md code
    """

    for class_member in inspect.getmembers(class_name):
        class_member_name = class_member[0]
        class_member_value = class_member[1]
        member_anchor = class_member_name
        member_signature = None
        member_description = None

        if class_member_name not in member_list:
            continue

        if inspect.getdoc(class_member_value):
            member_docs = inspect.getdoc(class_member_value).split("\n\n")
            if len(member_docs) >= 2:
                member_signature = member_docs[0]
                member_description = '\n'.join(member_docs[1:])
            else:
                member_description = member_docs[0]

            if class_member_name in ['from_parquet', 'read_parquet']:
                member_signature = '\n\n'.join(member_docs)
                member_description = "Create a relation object from the Parquet files"
            number_of_duplicates = (
                relational_api_table.filter(f"member_name = '{class_member_name}'")
                .count("member_name")
                .fetchone()
            )[0]
            if number_of_duplicates > 0:
                member_anchor = f"{class_member_name}-{number_of_duplicates}"

        member_details = DOCS_DETAILS_MAP.get(member_anchor, PythonRelAPIDetails())
        relational_api_table.insert(
            [
                class_name.__name__,
                class_member_name,
                section,
                SECTION_MAP.get(section).get("id"),
                f"```python\n{member_signature}\n```" if member_signature else None,
                f"{member_description}{member_details.additional_description}",
                (
                    '\n'.join(
                        [
                            f"""- **{parameter.parameter_name}** : {', '.join(parameter.parameter_type)}{", default: "+parameter.parameter_default if parameter.parameter_default else ''}
                            \n\t{parameter.parameter_description}"""
                            for parameter in member_details.parameters
                        ]
                    )
                    if member_details.parameters
                    else None
                ),
                f"| [`{class_member_name}`](#{member_anchor}) | {member_description} |",
                (
                    DEFAULT_EXAMPLE.format(
                        code_example=trim_code_block(member_details.example)
                    )
                    if member_details.use_default_example and member_details.example
                    else (
                        PLACEHOLDER_EXAMPLE.format(
                            code_example=trim_code_block(member_details.example)
                        )
                        if member_details.example
                        else None
                    )
                ),
                (
                    PLACEHOLDER_RESULT.format(
                        result=member_details.result,
                        result_type=member_details.result_type,
                    ).replace("\n\n", "\n")
                    if member_details.result
                    else None
                ),
                (
                    ', '.join(
                        f"[`{alias}`](#{alias})" for alias in member_details.aliases
                    )
                    if member_details.aliases
                    else None
                ),
            ]
        )


def generate_from_db(relational_api_table):
    with open(f"docs/{DUCKDB_DOC_VERSION}/clients/python/relational_api.md", "w") as f:
        f.write(FORMATTER_TEXT)
        f.write("\n")

        f.write(INTRODUCTION_TEXT)
        f.write("\n")

        # write section details
        section_details = (
            relational_api_table.select(
                """
            section,
            section_id,
            concat('#### ', '`', member_name, '`') as header_member_name, 
            if(member_signature is not null, '\n\n##### Signature\n\n', NULL) as header_signature, 
            member_signature,
            if(member_description is not null, '\n\n##### Description\n\n', NULL) as header_description, 
            member_description,
            if(member_parameters is not null, '\n\n##### Parameters\n\n', NULL) as header_parameters, 
            member_parameters,
            if(aliases != '', concat('\n\n**Aliases**: ', aliases), NULL) as aliases,
            if(member_example is not null, '\n\n##### Example\n\n', NULL) as header_example,
            member_example,
            if( member_result is not null, '\n\n##### Result\n\n', NULL) as header_result,
            member_result
        """
            )
            .select(
                """
                section, 
                section_id, 
                concat(
                    header_member_name, 
                    header_signature, 
                    member_signature, 
                    header_description, 
                    member_description,
                    aliases,
                    header_parameters,
                    member_parameters,
                    header_example, 
                    member_example, 
                    header_result, 
                    member_result
                ) as detailed_section
            """
            )
            .string_agg(
                "detailed_section",
                sep='\n\n----\n\n',
                groups='section, section_id',
                projected_columns='section, section_id',
            )
            .order("section_id")
        )

        for section in section_details.fetchall():
            f.write(f"\n\n## {section[0]} \n\n")
            f.write(SECTION_MAP.get(section[0]).get("description"))
            toc_section = (
                relational_api_table.filter(f"section_id={section[1]}")
                .select('section', "section_id", 'member_toc_line')
                .string_agg(
                    'member_toc_line',
                    sep='\n',
                    groups='section, section_id',
                    projected_columns='section, section_id',
                )
            ).fetchone()
            f.write("\n\n")
            f.write("| Name | Description |\n|:--|:-------|\n")
            f.write(toc_section[2])
            f.write("\n\n")
            f.write(section[2])

        f.write("\n")


def check_fully_documented(class_name, configured_in_script, class_members):
    if too_many_doc_members := list(set(configured_in_script) - set(class_members)):
        warnings.warn(
            f"The following members are not in the {class_name} anymore: {too_many_doc_members}"
        )
    if undocumented_members := list(set(class_members) - set(configured_in_script)):
        warnings.warn(
            f"There are members which are not documented for {class_name}: {undocumented_members}"
        )


def generate_python_relational_api_md():
    check_fully_documented(
        class_name="DuckDBPyRelation",
        configured_in_script=PY_RELATION_MEMBERS,
        class_members=[
            member[0]
            for member in inspect.getmembers(duckdb.DuckDBPyRelation)
            if not member[0].startswith("_")
        ],
    )

    check_fully_documented(
        class_name="DuckDBPyConnection",
        configured_in_script=CREATION_MEMBER_LIST,
        class_members=[
            member[0]
            for member in inspect.getmembers(duckdb.DuckDBPyConnection)
            if inspect.getdoc(member[1])
            and '-> duckdb.duckdb.DuckDBPyRelation' in inspect.getdoc(member[1])
        ],
    )

    duckdb_conn = get_duckdb_conn()

    relational_api_table = duckdb_conn.table("relational_api_members")

    for section, section_details in SECTION_MAP.items():
        for method_list in section_details.get("method_list"):
            populate_member_details(
                relational_api_table=relational_api_table,
                class_name=method_list["class"],
                member_list=method_list["members"],
                section=section,
            )

    generate_from_db(relational_api_table)


if __name__ == "__main__":
    generate_python_relational_api_md()
